// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: address.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const activateAddress = `-- name: ActivateAddress :exec
UPDATE addresses
SET is_active = true
WHERE id = $1
`

func (q *Queries) ActivateAddress(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, activateAddress, id)
	return err
}

const createAddress = `-- name: CreateAddress :one

INSERT INTO addresses (
    user_id,
    label,
    street_address,
    city,
    state,
    postal_code,
    country,
    latitude,
    longitude,
    instructions,
    is_default,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, address_id, user_id, label, street_address, city, state, postal_code, country, latitude, longitude, location, instructions, is_default, is_active, created_at, updated_at
`

type CreateAddressParams struct {
	UserID        string         `json:"user_id"`
	Label         sql.NullString `json:"label"`
	StreetAddress string         `json:"street_address"`
	City          string         `json:"city"`
	State         string         `json:"state"`
	PostalCode    string         `json:"postal_code"`
	Country       string         `json:"country"`
	Latitude      sql.NullString `json:"latitude"`
	Longitude     sql.NullString `json:"longitude"`
	Instructions  sql.NullString `json:"instructions"`
	IsDefault     sql.NullBool   `json:"is_default"`
	IsActive      sql.NullBool   `json:"is_active"`
}

// ============================================
// ADDRESS QUERIES
// ============================================
func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) (Address, error) {
	row := q.db.QueryRowContext(ctx, createAddress,
		arg.UserID,
		arg.Label,
		arg.StreetAddress,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.Instructions,
		arg.IsDefault,
		arg.IsActive,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.AddressID,
		&i.UserID,
		&i.Label,
		&i.StreetAddress,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Location,
		&i.Instructions,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateAddress = `-- name: DeactivateAddress :exec
UPDATE addresses
SET is_active = false
WHERE id = $1
`

func (q *Queries) DeactivateAddress(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deactivateAddress, id)
	return err
}

const deleteAddress = `-- name: DeleteAddress :exec
DELETE FROM addresses
WHERE id = $1
`

func (q *Queries) DeleteAddress(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAddress, id)
	return err
}

const findNearbyAddresses = `-- name: FindNearbyAddresses :many
SELECT 
    address_id,
    user_id,
    street_address,
    city,
    state,
    latitude,
    longitude,
    ST_Distance(
        location,
        ST_SetSRID(ST_MakePoint($2, $1), 4326)::geography
    ) / 1000 AS distance_km
FROM addresses
WHERE is_active = true
AND location IS NOT NULL
AND ST_DWithin(
    location,
    ST_SetSRID(ST_MakePoint($2, $1), 4326)::geography,
    $3 * 1000
)
ORDER BY distance_km ASC
LIMIT $4
`

type FindNearbyAddressesParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	Column3       interface{} `json:"column_3"`
	Limit         int32       `json:"limit"`
}

type FindNearbyAddressesRow struct {
	AddressID     string         `json:"address_id"`
	UserID        string         `json:"user_id"`
	StreetAddress string         `json:"street_address"`
	City          string         `json:"city"`
	State         string         `json:"state"`
	Latitude      sql.NullString `json:"latitude"`
	Longitude     sql.NullString `json:"longitude"`
	DistanceKm    int32          `json:"distance_km"`
}

func (q *Queries) FindNearbyAddresses(ctx context.Context, arg FindNearbyAddressesParams) ([]FindNearbyAddressesRow, error) {
	rows, err := q.db.QueryContext(ctx, findNearbyAddresses,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindNearbyAddressesRow{}
	for rows.Next() {
		var i FindNearbyAddressesRow
		if err := rows.Scan(
			&i.AddressID,
			&i.UserID,
			&i.StreetAddress,
			&i.City,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAddress = `-- name: GetAddress :one
SELECT id, address_id, user_id, label, street_address, city, state, postal_code, country, latitude, longitude, location, instructions, is_default, is_active, created_at, updated_at FROM addresses
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAddress(ctx context.Context, id uuid.UUID) (Address, error) {
	row := q.db.QueryRowContext(ctx, getAddress, id)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.AddressID,
		&i.UserID,
		&i.Label,
		&i.StreetAddress,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Location,
		&i.Instructions,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAddressByAddressID = `-- name: GetAddressByAddressID :one
SELECT id, address_id, user_id, label, street_address, city, state, postal_code, country, latitude, longitude, location, instructions, is_default, is_active, created_at, updated_at FROM addresses
WHERE address_id = $1 LIMIT 1
`

func (q *Queries) GetAddressByAddressID(ctx context.Context, addressID string) (Address, error) {
	row := q.db.QueryRowContext(ctx, getAddressByAddressID, addressID)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.AddressID,
		&i.UserID,
		&i.Label,
		&i.StreetAddress,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Location,
		&i.Instructions,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAddressesByPostalCode = `-- name: GetAddressesByPostalCode :many
SELECT id, address_id, user_id, label, street_address, city, state, postal_code, country, latitude, longitude, location, instructions, is_default, is_active, created_at, updated_at FROM addresses
WHERE postal_code = $1
AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) GetAddressesByPostalCode(ctx context.Context, postalCode string) ([]Address, error) {
	rows, err := q.db.QueryContext(ctx, getAddressesByPostalCode, postalCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Address{}
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.AddressID,
			&i.UserID,
			&i.Label,
			&i.StreetAddress,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Location,
			&i.Instructions,
			&i.IsDefault,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultAddress = `-- name: GetDefaultAddress :one
SELECT id, address_id, user_id, label, street_address, city, state, postal_code, country, latitude, longitude, location, instructions, is_default, is_active, created_at, updated_at FROM addresses
WHERE user_id = $1 
AND is_default = true 
AND is_active = true
LIMIT 1
`

func (q *Queries) GetDefaultAddress(ctx context.Context, userID string) (Address, error) {
	row := q.db.QueryRowContext(ctx, getDefaultAddress, userID)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.AddressID,
		&i.UserID,
		&i.Label,
		&i.StreetAddress,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Location,
		&i.Instructions,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllUserAddresses = `-- name: ListAllUserAddresses :many
SELECT id, address_id, user_id, label, street_address, city, state, postal_code, country, latitude, longitude, location, instructions, is_default, is_active, created_at, updated_at FROM addresses
WHERE user_id = $1
ORDER BY is_default DESC, is_active DESC, created_at DESC
`

func (q *Queries) ListAllUserAddresses(ctx context.Context, userID string) ([]Address, error) {
	rows, err := q.db.QueryContext(ctx, listAllUserAddresses, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Address{}
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.AddressID,
			&i.UserID,
			&i.Label,
			&i.StreetAddress,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Location,
			&i.Instructions,
			&i.IsDefault,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAddresses = `-- name: ListUserAddresses :many
SELECT id, address_id, user_id, label, street_address, city, state, postal_code, country, latitude, longitude, location, instructions, is_default, is_active, created_at, updated_at FROM addresses
WHERE user_id = $1
AND is_active = true
ORDER BY is_default DESC, created_at DESC
`

func (q *Queries) ListUserAddresses(ctx context.Context, userID string) ([]Address, error) {
	rows, err := q.db.QueryContext(ctx, listUserAddresses, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Address{}
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.AddressID,
			&i.UserID,
			&i.Label,
			&i.StreetAddress,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Location,
			&i.Instructions,
			&i.IsDefault,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAddressesByCity = `-- name: SearchAddressesByCity :many
SELECT id, address_id, user_id, label, street_address, city, state, postal_code, country, latitude, longitude, location, instructions, is_default, is_active, created_at, updated_at FROM addresses
WHERE city ILIKE $1
AND is_active = true
ORDER BY created_at DESC
LIMIT $2
`

type SearchAddressesByCityParams struct {
	City  string `json:"city"`
	Limit int32  `json:"limit"`
}

func (q *Queries) SearchAddressesByCity(ctx context.Context, arg SearchAddressesByCityParams) ([]Address, error) {
	rows, err := q.db.QueryContext(ctx, searchAddressesByCity, arg.City, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Address{}
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.AddressID,
			&i.UserID,
			&i.Label,
			&i.StreetAddress,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Location,
			&i.Instructions,
			&i.IsDefault,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultAddress = `-- name: SetDefaultAddress :exec
UPDATE addresses
SET is_default = CASE 
    WHEN address_id = $2 THEN true 
    ELSE false 
END
WHERE user_id = $1
`

type SetDefaultAddressParams struct {
	UserID    string `json:"user_id"`
	AddressID string `json:"address_id"`
}

func (q *Queries) SetDefaultAddress(ctx context.Context, arg SetDefaultAddressParams) error {
	_, err := q.db.ExecContext(ctx, setDefaultAddress, arg.UserID, arg.AddressID)
	return err
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE addresses
SET 
    label = COALESCE($2, label),
    street_address = COALESCE($3, street_address),
    city = COALESCE($4, city),
    state = COALESCE($5, state),
    postal_code = COALESCE($6, postal_code),
    country = COALESCE($7, country),
    latitude = COALESCE($8, latitude),
    longitude = COALESCE($9, longitude),
    instructions = COALESCE($10, instructions),
    is_default = COALESCE($11, is_default),
    is_active = COALESCE($12, is_active)
WHERE id = $1
RETURNING id, address_id, user_id, label, street_address, city, state, postal_code, country, latitude, longitude, location, instructions, is_default, is_active, created_at, updated_at
`

type UpdateAddressParams struct {
	ID            uuid.UUID      `json:"id"`
	Label         sql.NullString `json:"label"`
	StreetAddress sql.NullString `json:"street_address"`
	City          sql.NullString `json:"city"`
	State         sql.NullString `json:"state"`
	PostalCode    sql.NullString `json:"postal_code"`
	Country       sql.NullString `json:"country"`
	Latitude      sql.NullString `json:"latitude"`
	Longitude     sql.NullString `json:"longitude"`
	Instructions  sql.NullString `json:"instructions"`
	IsDefault     sql.NullBool   `json:"is_default"`
	IsActive      sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (Address, error) {
	row := q.db.QueryRowContext(ctx, updateAddress,
		arg.ID,
		arg.Label,
		arg.StreetAddress,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.Instructions,
		arg.IsDefault,
		arg.IsActive,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.AddressID,
		&i.UserID,
		&i.Label,
		&i.StreetAddress,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Location,
		&i.Instructions,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
