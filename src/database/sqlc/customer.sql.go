// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customer.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one

INSERT INTO customers (
    user_id,
    company_name,
    business_type,
    billing_address,
    payment_method,
    credit_limit
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, user_id, company_name, business_type, billing_address, payment_method, credit_limit, created_at, updated_at, customer_id
`

type CreateCustomerParams struct {
	UserID         string         `json:"user_id"`
	CompanyName    sql.NullString `json:"company_name"`
	BusinessType   sql.NullString `json:"business_type"`
	BillingAddress string         `json:"billing_address"`
	PaymentMethod  sql.NullString `json:"payment_method"`
	CreditLimit    sql.NullString `json:"credit_limit"`
}

// ============================================
// CUSTOMER QUERIES
// ============================================
func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.UserID,
		arg.CompanyName,
		arg.BusinessType,
		arg.BillingAddress,
		arg.PaymentMethod,
		arg.CreditLimit,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.BusinessType,
		&i.BillingAddress,
		&i.PaymentMethod,
		&i.CreditLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
	)
	return i, err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, user_id, company_name, business_type, billing_address, payment_method, credit_limit, created_at, updated_at, customer_id FROM customers
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCustomer(ctx context.Context, id uuid.UUID) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.BusinessType,
		&i.BillingAddress,
		&i.PaymentMethod,
		&i.CreditLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
	)
	return i, err
}

const getCustomerByCustomerID = `-- name: GetCustomerByCustomerID :one
SELECT id, user_id, company_name, business_type, billing_address, payment_method, credit_limit, created_at, updated_at, customer_id FROM customers
WHERE customer_id = $1 LIMIT 1
`

func (q *Queries) GetCustomerByCustomerID(ctx context.Context, customerID string) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByCustomerID, customerID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.BusinessType,
		&i.BillingAddress,
		&i.PaymentMethod,
		&i.CreditLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
	)
	return i, err
}

const getCustomerByUserID = `-- name: GetCustomerByUserID :one
SELECT id, user_id, company_name, business_type, billing_address, payment_method, credit_limit, created_at, updated_at, customer_id FROM customers
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetCustomerByUserID(ctx context.Context, userID string) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByUserID, userID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.BusinessType,
		&i.BillingAddress,
		&i.PaymentMethod,
		&i.CreditLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
	)
	return i, err
}

const getCustomerWithUser = `-- name: GetCustomerWithUser :one
SELECT 
    c.id, c.user_id, c.company_name, c.business_type, c.billing_address, c.payment_method, c.credit_limit, c.created_at, c.updated_at, c.customer_id,
    u.first_name,
    u.last_name,
    u.email,
    u.phone,
    u.avatar,
    u.status as user_status
FROM customers c
INNER JOIN users u ON c.user_id = u.user_id
WHERE c.customer_id = $1
LIMIT 1
`

type GetCustomerWithUserRow struct {
	ID             uuid.UUID      `json:"id"`
	UserID         string         `json:"user_id"`
	CompanyName    sql.NullString `json:"company_name"`
	BusinessType   sql.NullString `json:"business_type"`
	BillingAddress string         `json:"billing_address"`
	PaymentMethod  sql.NullString `json:"payment_method"`
	CreditLimit    sql.NullString `json:"credit_limit"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	CustomerID     string         `json:"customer_id"`
	FirstName      string         `json:"first_name"`
	LastName       string         `json:"last_name"`
	Email          string         `json:"email"`
	Phone          string         `json:"phone"`
	Avatar         sql.NullString `json:"avatar"`
	UserStatus     string         `json:"user_status"`
}

func (q *Queries) GetCustomerWithUser(ctx context.Context, customerID string) (GetCustomerWithUserRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerWithUser, customerID)
	var i GetCustomerWithUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.BusinessType,
		&i.BillingAddress,
		&i.PaymentMethod,
		&i.CreditLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.Avatar,
		&i.UserStatus,
	)
	return i, err
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers
SET 
    company_name = COALESCE($2, company_name),
    business_type = COALESCE($3, business_type),
    billing_address = COALESCE($4, billing_address),
    payment_method = COALESCE($5, payment_method),
    credit_limit = COALESCE($6, credit_limit),
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, company_name, business_type, billing_address, payment_method, credit_limit, created_at, updated_at, customer_id
`

type UpdateCustomerParams struct {
	ID             uuid.UUID      `json:"id"`
	CompanyName    sql.NullString `json:"company_name"`
	BusinessType   sql.NullString `json:"business_type"`
	BillingAddress string         `json:"billing_address"`
	PaymentMethod  sql.NullString `json:"payment_method"`
	CreditLimit    sql.NullString `json:"credit_limit"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, updateCustomer,
		arg.ID,
		arg.CompanyName,
		arg.BusinessType,
		arg.BillingAddress,
		arg.PaymentMethod,
		arg.CreditLimit,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.BusinessType,
		&i.BillingAddress,
		&i.PaymentMethod,
		&i.CreditLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
	)
	return i, err
}
